'use client';

import { useEffect, useState } from 'react';
import { RequireAdmin } from '@/components/AuthGuard';
import { LEVEL_LABELS } from '@/app/players/types';
import AttendanceStatus from '@/app/players/components/AttendanceStatus';
import MatchSessionStatus from '@/app/players/components/MatchSessionStatus';
import MatchGenerationControls from '@/app/players/components/MatchGenerationControls';
import GeneratedMatchesList from '@/app/players/components/GeneratedMatchesList';
import TeamBasedMatchGeneration from '@/app/players/components/TeamBasedMatchGeneration';
import { ExtendedPlayer, MatchSession } from '@/app/players/types';
import { getSupabaseClient } from '@/lib/supabase';
import { fetchTodayPlayers, fetchRegisteredPlayersForDate, calculatePlayerGameCounts, normalizeLevel } from '@/app/players/utils';
import { Match } from '@/types';

const supabase = getSupabaseClient();

export default function PlayersTodayPage() {
  const [todayPlayers, setTodayPlayers] = useState<ExtendedPlayer[] | null>(null);
  const [matchSessions, setMatchSessions] = useState<MatchSession[]>([]);
  const [todaySchedules, setTodaySchedules] = useState<Array<{
    id: string;
    match_date: string;
    start_time: string;
    end_time: string;
    location: string;
    status: string;
    current_participants: number | null;
    max_participants: number | null;
  }>>([]);
  const [matches, setMatches] = useState<Match[]>([]);
  const [playerGameCounts, setPlayerGameCounts] = useState<Record<string, number>>({});
  const [loading, setLoading] = useState(false);
  const [assignType, setAssignType] = useState<'today' | 'scheduled'>('today');
  const [sessionMode, setSessionMode] = useState<'Î†àÎ≤®' | 'ÎûúÎç§' | 'ÌòºÎ≥µ' | 'ÏàòÎèô'>('Î†àÎ≤®');
  const [perPlayerMinGames, setPerPlayerMinGames] = useState<number>(1);
  const [isManualEditing, setIsManualEditing] = useState(false);
  const [availableTeams, setAvailableTeams] = useState<Array<{round: number; title?: string; racket: string[]; shuttle: string[]}>>([]);
  const [selectedTeamRound, setSelectedTeamRound] = useState<number | null>(null);

  // Î°úÏª¨(KST) Í∏∞Ï§Ä YYYY-MM-DD Î∞òÌôò (ÌÉÄÏûÑÏ°¥ Î¨∏Ï†ú Ìï¥Í≤∞)
  const getTodayLocal = () => {
    const now = new Date();
    // Î°úÏª¨ ÌÉÄÏûÑÏ°¥Ïùò Ïò§Îäò ÎÇ†ÏßúÎ•º Ï†ïÌôïÌûà Í≥ÑÏÇ∞
    const year = now.getFullYear();
    const month = String(now.getMonth() + 1).padStart(2, '0');
    const day = String(now.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
  };

  // Ï∂úÏÑù Îç∞Ïù¥ÌÑ∞ Í∞±Ïã† Ìï®Ïàò
  const refreshAttendanceData = async () => {
    const today = getTodayLocal();
    console.log('Ï∂úÏÑù Îç∞Ïù¥ÌÑ∞ Í∞±Ïã† ÏãúÏûë - ÎÇ†Ïßú:', today);

    try {
      // Ïò§Îäò Í≤ΩÍ∏∞ Ï∞∏Í∞ÄÏûê Ï°∞Ìöå
      const participants = await fetchRegisteredPlayersForDate(today);
      console.log('Ï∞∏Í∞ÄÏûê Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå Í≤∞Í≥º:', participants);
      
      if (!participants || participants.length === 0) {
        console.log('Ïò§Îäò Îì±Î°ùÎêú Ï∞∏Í∞ÄÏûêÍ∞Ä ÏóÜÏäµÎãàÎã§.');
        setTodayPlayers([]);
        return;
      }

      // Ïò§Îäò Ï∂úÏÑù Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå
      const { data: attendancePresent, error: attErr } = await supabase
        .from('attendances')
        .select('user_id')
        .eq('attended_at', today)
        .eq('status', 'present');
        
      if (attErr) {
        console.error('Ï∂úÏÑù Ï°∞Ìöå Ïò§Î•ò:', attErr);
        // Ï∂úÏÑù Ï°∞Ìöå Ïã§Ìå®Ìï¥ÎèÑ Ï∞∏Í∞ÄÏûêÎäî absent ÏÉÅÌÉúÎ°ú ÌëúÏãú
        const absentPlayers = participants.map(p => ({ ...p, status: 'absent' as const }));
        setTodayPlayers(absentPlayers);
        return;
      }

      console.log('Ï∂úÏÑù Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå Í≤∞Í≥º:', attendancePresent);

      // Ï∞∏Í∞ÄÏûêÍ∞Ä ÏóÜÍ≥† Ï∂úÏÑù Îç∞Ïù¥ÌÑ∞Îßå ÏûàÎäî Í≤ΩÏö∞: Ï∂úÏÑù Îç∞Ïù¥ÌÑ∞Î•º Ï∞∏Í∞ÄÏûêÎ°ú Î≥ÄÌôò
      if ((!participants || participants.length === 0) && attendancePresent && attendancePresent.length > 0) {
        console.log('Ï∞∏Í∞ÄÏûê Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏñ¥ Ï∂úÏÑù Îç∞Ïù¥ÌÑ∞Î•º Ï∞∏Í∞ÄÏûêÎ°ú ÏÇ¨Ïö©');

        // Ï∂úÏÑùÌïú ÏÇ¨Ïö©ÏûêÎì§Ïùò ÌîÑÎ°úÌïÑ Ï°∞Ìöå
        const attendanceUserIds = attendancePresent.map((a: any) => a.user_id);
        const { data: profiles, error: profileErr } = await supabase
          .from('profiles')
          .select('id, username, full_name, skill_level, gender')
          .in('id', attendanceUserIds);

        if (profileErr) {
          console.error('ÌîÑÎ°úÌïÑ Ï°∞Ìöå Ïò§Î•ò:', profileErr);
          setTodayPlayers([]);
          return;
        }

        // Î†àÎ≤® Ï†ïÎ≥¥ Ï°∞Ìöå
        const { data: levelData } = await supabase
          .from('level_info')
          .select('code, name');

        const levelMap: Record<string, string> = {};
        (levelData || []).forEach((lvl: any) => {
          if (lvl.code) levelMap[String(lvl.code).toLowerCase()] = lvl.name || '';
        });

        // Ï∂úÏÑù Îç∞Ïù¥ÌÑ∞Î•º Ï∞∏Í∞ÄÏûê Îç∞Ïù¥ÌÑ∞Î°ú Î≥ÄÌôò
        const playersFromAttendance: ExtendedPlayer[] = (profiles || []).map((profile: any) => {
          const raw = (profile.skill_level || '').toString().toLowerCase();
          const normalized = normalizeLevel('', raw);
          const label = levelMap[normalized] || LEVEL_LABELS[normalized] || 'E2 (Ï¥àÍ∏â)';
          const name = profile.username || profile.full_name || `ÏÑ†Ïàò-${String(profile.id).slice(0, 4)}`;
          return {
            id: profile.id,
            name,
            skill_level: normalized,
            skill_label: label,
            gender: profile.gender || '',
            skill_code: '',
            status: 'present', // Ï∂úÏÑù Îç∞Ïù¥ÌÑ∞Ïù¥ÎØÄÎ°ú presentÎ°ú ÏÑ§Ï†ï
          } as ExtendedPlayer;
        });

        console.log(`Ï∂úÏÑù Îç∞Ïù¥ÌÑ∞ÏóêÏÑú ${playersFromAttendance.length}Î™Ö Ï∞∏Í∞ÄÏûê ÏÉùÏÑ±`);
        setTodayPlayers(playersFromAttendance);
        return;
      }

      // Ï∞∏Í∞ÄÏûêÏôÄ Ï∂úÏÑù Îç∞Ïù¥ÌÑ∞ Í≤∞Ìï©
      const attendanceMap = new Map(attendancePresent?.map((a: any) => [a.user_id, true]) || []);
      const combinedPlayers = participants.map(p => ({
        ...p,
        status: attendanceMap.has(p.id) ? 'present' : 'absent'
      })) as ExtendedPlayer[];

      console.log('ÏµúÏ¢Ö Í≤∞Ìï©Îêú ÌîåÎ†àÏù¥Ïñ¥ Îç∞Ïù¥ÌÑ∞:', combinedPlayers);
      setTodayPlayers(combinedPlayers);

    } catch (error) {
      console.error('Ï∂úÏÑù Îç∞Ïù¥ÌÑ∞ Í∞±Ïã† Ïò§Î•ò:', error);
      // Ïò§Î•ò Î∞úÏÉù ÏãúÏóêÎèÑ Ï∞∏Í∞ÄÏûê Îç∞Ïù¥ÌÑ∞Îäî absent ÏÉÅÌÉúÎ°ú ÌëúÏãú
      try {
        const participants = await fetchRegisteredPlayersForDate(today);
        const absentPlayers = participants.map(p => ({ ...p, status: 'absent' as const }));
        setTodayPlayers(absentPlayers);
      } catch (fallbackError) {
        console.error('Ï∞∏Í∞ÄÏûê Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå Ïã§Ìå®:', fallbackError);
        setTodayPlayers([]);
      }
    }
  };

  useEffect(() => {
    const init = async () => {
      console.log('ÌéòÏù¥ÏßÄ Ï¥àÍ∏∞ Î°úÎî© ÏãúÏûë');
      await refreshAttendanceData();
      await fetchMatchSessions();
      await fetchTodaySchedules();
      await fetchTodayTeams();
      console.log('ÌéòÏù¥ÏßÄ Ï¥àÍ∏∞ Î°úÎî© ÏôÑÎ£å');
    };
    init();
  }, []);

  // Ìè¨Ïª§Ïä§ Ïãú Í∞±Ïã†: Ïò§Îäò ÏÑ∏ÏÖò/ÏùºÏ†ï/ÌåÄ Íµ¨ÏÑ± Ïû¨Ï°∞Ìöå
  useEffect(() => {
    const onFocus = () => {
      console.log('ÌéòÏù¥ÏßÄ Ìè¨Ïª§Ïä§ - Îç∞Ïù¥ÌÑ∞ Í∞±Ïã†');
      refreshAttendanceData().catch(err => console.error('Ìè¨Ïª§Ïä§ Í∞±Ïã† Ïò§Î•ò:', err));
      fetchMatchSessions();
      fetchTodaySchedules();
      fetchTodayTeams();
    };
    window.addEventListener('focus', onFocus);
    return () => window.removeEventListener('focus', onFocus);
  }, []);

  // Ïã§ÏãúÍ∞Ñ Íµ¨ÎèÖ: Ï∂úÏÑù Îç∞Ïù¥ÌÑ∞ Î≥ÄÍ≤Ω Ïãú ÏûêÎèô Í∞±Ïã†
  useEffect(() => {
    const today = getTodayLocal();
    
    console.log('Ïã§ÏãúÍ∞Ñ Íµ¨ÎèÖ ÏÑ§Ï†ï - Ïò§Îäò ÎÇ†Ïßú:', today);
    
    const attendanceChannel = supabase
      .channel('attendance_changes')
      .on('postgres_changes', { 
        event: '*', 
        schema: 'public', 
        table: 'attendances',
        filter: `attended_at=eq.${today}`
      }, (payload) => {
        console.log('Ï∂úÏÑù Îç∞Ïù¥ÌÑ∞ Î≥ÄÍ≤Ω Í∞êÏßÄ:', payload);
        // ÎπÑÎèôÍ∏∞ Ìï®ÏàòÎ•º Ï¶âÏãú Ïã§ÌñâÌïòÏó¨ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ Î≥¥Ïû•
        refreshAttendanceData().catch(err => console.error('Ïã§ÏãúÍ∞Ñ Í∞±Ïã† Ïò§Î•ò:', err));
      })
      .subscribe();

    const participantChannel = supabase
      .channel('participant_changes')
      .on('postgres_changes', { 
        event: '*', 
        schema: 'public', 
        table: 'match_participants'
      }, (payload) => {
        console.log('Ï∞∏Í∞ÄÏûê Îç∞Ïù¥ÌÑ∞ Î≥ÄÍ≤Ω Í∞êÏßÄ:', payload);
        // ÎπÑÎèôÍ∏∞ Ìï®ÏàòÎ•º Ï¶âÏãú Ïã§ÌñâÌïòÏó¨ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ Î≥¥Ïû•
        refreshAttendanceData().catch(err => console.error('Ïã§ÏãúÍ∞Ñ Í∞±Ïã† Ïò§Î•ò:', err));
      })
      .subscribe();

    const scheduleChannel = supabase
      .channel('schedule_changes')
      .on('postgres_changes', { 
        event: '*', 
        schema: 'public', 
        table: 'match_schedules',
        filter: `match_date=eq.${today}`
      }, (payload) => {
        console.log('Í≤ΩÍ∏∞ ÏùºÏ†ï Î≥ÄÍ≤Ω Í∞êÏßÄ:', payload);
        // Í≤ΩÍ∏∞ ÏùºÏ†ï Î≥ÄÍ≤Ω Ïãú ÏùºÏ†ï Î™©Î°ùÎèÑ Í∞±Ïã†
        fetchTodaySchedules();
      })
      .subscribe();

    return () => {
      console.log('Ïã§ÏãúÍ∞Ñ Íµ¨ÎèÖ Ìï¥Ï†ú');
      supabase.removeChannel(attendanceChannel);
      supabase.removeChannel(participantChannel);
      supabase.removeChannel(scheduleChannel);
    };
  }, []);

  const fetchMatchSessions = async () => {
    try {
  const today = getTodayLocal();
      const { data, error } = await supabase
        .from('match_sessions')
        .select('*')
        .eq('session_date', today)
        .order('created_at', { ascending: false });
      if (error) throw error;
      setMatchSessions(data || []);
    } catch (e) {
      console.error('ÏÑ∏ÏÖò Ï°∞Ìöå Ïò§Î•ò:', e);
    }
  };

  const fetchTodayTeams = async () => {
    try {
      const today = getTodayLocal();
      console.log('üîç ÌåÄ Íµ¨ÏÑ± Ï°∞Ìöå ÏãúÏûë - ÎÇ†Ïßú:', today);
      
      // 1. Î®ºÏ†Ä DBÏóêÏÑú Ï°∞Ìöå ÏãúÎèÑ (ÏÉàÎ°úÏö¥ JSONB Íµ¨Ï°∞)
      const { data, error } = await supabase
        .from('team_assignments')
        .select('*')
        .eq('assignment_date', today)
        .order('round_number', { ascending: true });

      let teamsData: any[] = [];

      if (error) {
        console.log('‚ö†Ô∏è DB Ï°∞Ìöå Ïò§Î•ò:', error.message);
        console.log('üì¶ Î°úÏª¨ Ïä§ÌÜ†Î¶¨ÏßÄÏóêÏÑú Ï°∞Ìöå ÏãúÎèÑ...');
      } else if (data && data.length > 0) {
        console.log('‚úÖ DBÏóêÏÑú', data.length, 'Í±¥ Ï°∞ÌöåÎê® (JSONB Íµ¨Ï°∞)');
        
        // JSONB Íµ¨Ï°∞Î•º Î∞∞Ïó¥Î°ú Î≥ÄÌôò
        teamsData = data.map(row => ({
          round: row.round_number,
          title: row.title,
          racket: Array.isArray(row.racket_team) ? row.racket_team : [],
          shuttle: Array.isArray(row.shuttle_team) ? row.shuttle_team : [],
          team_type: row.team_type
        }));
      } else {
        console.log('üì¶ DBÏóê Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå. Î°úÏª¨ Ïä§ÌÜ†Î¶¨ÏßÄÏóêÏÑú Ï°∞Ìöå ÏãúÎèÑ...');
      }

      // 2. DBÏóêÏÑú Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏúºÎ©¥ Î°úÏª¨ Ïä§ÌÜ†Î¶¨ÏßÄÏóêÏÑú Ï°∞Ìöå (Íµ¨ Î∞©Ïãù)
      if (teamsData.length === 0) {
        const localData = localStorage.getItem('badminton_team_assignments');
        if (localData) {
          try {
            const allAssignments = JSON.parse(localData);
            console.log('üì¶ Î°úÏª¨ Ïä§ÌÜ†Î¶¨ÏßÄ Ï†ÑÏ≤¥ Îç∞Ïù¥ÌÑ∞:', allAssignments.length, 'Í±¥');
            
            // Ïò§Îäò ÎÇ†Ïßú Îç∞Ïù¥ÌÑ∞Îßå ÌïÑÌÑ∞ÎßÅ
            const todayAssignments = allAssignments.filter((assignment: any) => {
              const assignmentDate = assignment.assignment_date || 
                                     assignment.created_at?.slice(0, 10) || 
                                     new Date(assignment.created_at).toISOString().slice(0, 10);
              return assignmentDate === today;
            });
            
            console.log('üì¶ Ïò§Îäò ÎÇ†Ïßú Îç∞Ïù¥ÌÑ∞:', todayAssignments.length, 'Í±¥ ÌïÑÌÑ∞ÎßÅÎê®');
            
            // ÌöåÏ∞®Î≥ÑÎ°ú Í∑∏Î£πÌôî (Íµ¨ Î∞©Ïãù)
            const teamsMap: Record<number, {round: number; title?: string; racket: string[]; shuttle: string[]}> = {};
            
            todayAssignments.forEach((assignment: any) => {
              if (!teamsMap[assignment.round_number]) {
                teamsMap[assignment.round_number] = {
                  round: assignment.round_number,
                  title: assignment.round_title,
                  racket: [],
                  shuttle: []
                };
              }
              
              if (assignment.team_type === 'racket') {
                teamsMap[assignment.round_number].racket.push(assignment.player_name);
              } else if (assignment.team_type === 'shuttle') {
                teamsMap[assignment.round_number].shuttle.push(assignment.player_name);
              }
            });
            
            teamsData = Object.values(teamsMap);
          } catch (parseError) {
            console.error('Î°úÏª¨ Ïä§ÌÜ†Î¶¨ÏßÄ ÌååÏã± Ïò§Î•ò:', parseError);
          }
        } else {
          console.log('üì¶ Î°úÏª¨ Ïä§ÌÜ†Î¶¨ÏßÄÏóêÎèÑ Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå');
        }
      }

      // 3. ÏµúÏ¢Ö Îç∞Ïù¥ÌÑ∞ ÏÑ§Ï†ï
      if (teamsData.length > 0) {
        setAvailableTeams(teamsData);
        console.log('‚úÖ ÏµúÏ¢Ö ÌåÄ Íµ¨ÏÑ±:', teamsData.length, 'Í∞ú ÌöåÏ∞®');
        teamsData.forEach(team => {
          console.log(`  - ${team.round}ÌöåÏ∞® (${team.title}): ÎùºÏºìÌåÄ ${team.racket.length}Î™Ö, ÏÖîÌãÄÌåÄ ${team.shuttle.length}Î™Ö`);
        });
      } else {
        console.log('‚ùå Ïò§Îäò ÎÇ†ÏßúÏùò ÌåÄ Íµ¨ÏÑ±Ïù¥ ÏóÜÏäµÎãàÎã§.');
        setAvailableTeams([]);
      }
    } catch (e) {
      console.error('ÌåÄ Íµ¨ÏÑ± Ï°∞Ìöå Ïã§Ìå®:', e);
      setAvailableTeams([]);
    }
  };

  const fetchTodaySchedules = async () => {
    try {
      const today = getTodayLocal();
      const { data, error } = await supabase
        .from('match_schedules')
        .select('id, match_date, start_time, end_time, location, status, current_participants, max_participants')
        .eq('match_date', today)
        .order('start_time', { ascending: true });

      if (error) throw error;

      // Ïã§Ï†ú Ï∞∏Í∞ÄÏûê ÏàòÎ°ú current_participants ÏóÖÎç∞Ïù¥Ìä∏
      if (data && data.length > 0) {
        for (const schedule of data) {
          // Ìï¥Îãπ ÏùºÏ†ïÏùò Ïã§Ï†ú Ï∞∏Í∞ÄÏûê Ïàò Ï°∞Ìöå
          const { count: actualCount, error: countError } = await supabase
            .from('match_participants')
            .select('*', { count: 'exact', head: true })
            .eq('match_schedule_id', schedule.id)
            .eq('status', 'registered');

          if (!countError && actualCount !== schedule.current_participants) {
            // current_participantsÍ∞Ä Ïã§Ï†ú Ï∞∏Í∞ÄÏûê ÏàòÏôÄ Îã§Î•¥Î©¥ ÏóÖÎç∞Ïù¥Ìä∏
            await supabase
              .from('match_schedules')
              .update({ current_participants: actualCount || 0 })
              .eq('id', schedule.id);

            console.log(`Í≤ΩÍ∏∞ ÏùºÏ†ï ${schedule.id} Ï∞∏Í∞ÄÏûê Ïàò ÏóÖÎç∞Ïù¥Ìä∏: ${schedule.current_participants} ‚Üí ${actualCount || 0}`);
          }
        }

        // ÏóÖÎç∞Ïù¥Ìä∏Îêú Îç∞Ïù¥ÌÑ∞ Îã§Ïãú Ï°∞Ìöå
        const { data: updatedData, error: refetchError } = await supabase
          .from('match_schedules')
          .select('id, match_date, start_time, end_time, location, status, current_participants, max_participants')
          .eq('match_date', today)
          .order('start_time', { ascending: true });

        if (!refetchError) {
          setTodaySchedules(updatedData || []);
        } else {
          setTodaySchedules(data || []);
        }
      } else {
        setTodaySchedules(data || []);
      }
    } catch (e) {
      console.error('Ïò§Îäò Í≤ΩÍ∏∞ ÏùºÏ†ï Ï°∞Ìöå Ïò§Î•ò:', e);
    }
  };

  const handleAssignByLevel = async () => {
    if (!todayPlayers) return;
    setLoading(true);
    try {
      const present = todayPlayers.filter(p => p.status === 'present');
      if (present.length < 4) {
        alert('ÏµúÏÜå 4Î™ÖÏùò Ï∂úÏÑùÏûêÍ∞Ä ÌïÑÏöîÌï©ÎãàÎã§.');
        return;
      }
      const playersForMatch = present.map(p => ({ ...p, skill_level: normalizeLevel(p.skill_level) }));
      const { createBalancedDoublesMatches } = await import('@/utils/match-utils');
      
      // Î™©Ìëú Í≤ΩÍ∏∞Ïàò Í≥ÑÏÇ∞
      const targetMatches = Math.ceil((playersForMatch.length * perPlayerMinGames) / 4);
      
      // Ïû¨ÏãúÎèÑ Î°úÏßÅ: ÏµúÎåÄ 4Ìöå ÏãúÎèÑÌïòÎ©∞ ÏΩîÌä∏ ÏàòÎ•º Ï†êÏßÑÏ†ÅÏúºÎ°ú Ï¶ùÍ∞Ä
      let generated: any[] = [];
      let attempts = 0;
      let maxCourts = Math.max(4, Math.ceil(playersForMatch.length / 4));
      
      while (attempts < 4) {
        generated = createBalancedDoublesMatches(playersForMatch, maxCourts, perPlayerMinGames)
          .map((m: any, i: number) => ({ ...m, court: i + 1 }));
        
        const counts = calculatePlayerGameCounts(generated);
        const missing = playersForMatch.filter(p => (counts[p.id] || 0) < perPlayerMinGames);
        
        // Î™©Ìëú Í≤ΩÍ∏∞ÏàòÎ•º ÎßåÏ°±ÌïòÍ≥† Î™®Îì† ÏÑ†ÏàòÍ∞Ä ÏµúÏÜå Í≤ΩÍ∏∞ÏàòÎ•º Ï±ÑÏõ†Îã§Î©¥ ÏÑ±Í≥µ
        if (generated.length >= targetMatches && missing.length === 0) {
          break;
        }
        
        attempts += 1;
        maxCourts = Math.min(playersForMatch.length, maxCourts + 2);
      }
      
      // ÏµúÏ¢Ö Í≤ÄÏ¶ù: Î™®Îì† Ï∂úÏÑùÏûêÍ∞Ä Ìè¨Ìï®ÎêòÏóàÎäîÏßÄ ÌôïÏù∏
      const finalCounts = calculatePlayerGameCounts(generated);
      const stillMissing = playersForMatch.filter(p => (finalCounts[p.id] || 0) < perPlayerMinGames);
      
      if (stillMissing.length > 0) {
        const missingNames = stillMissing.map(p => p.name).join(', ');
        console.warn(`‚ö†Ô∏è ${stillMissing.length}Î™ÖÏùò ÏÑ†ÏàòÍ∞Ä Î™©Ìëú Í≤ΩÍ∏∞ÏàòÏóê ÎèÑÎã¨ÌïòÏßÄ Î™ªÌñàÏäµÎãàÎã§:`, missingNames);
        console.warn(`ÏÉùÏÑ±Îêú Í≤ΩÍ∏∞: ${generated.length}Í∞ú, Î™©Ìëú: ${targetMatches}Í∞ú`);
      }
      
      // Ï†ÑÏ≤¥ Ï∞∏Í∞ÄÏûê ÌÜµÍ≥Ñ Ï∂úÎ†•
      console.log('üìä Î†àÎ≤®Î≥Ñ Í≤ΩÍ∏∞ ÏÉùÏÑ± ÏôÑÎ£å:');
      console.log(`- Ï¥ù Ï∂úÏÑùÏûê: ${playersForMatch.length}Î™Ö`);
      console.log(`- ÏÉùÏÑ±Îêú Í≤ΩÍ∏∞: ${generated.length}Í∞ú`);
      console.log(`- Î™©Ìëú Í≤ΩÍ∏∞Ïàò: ${targetMatches}Í∞ú`);
      console.log(`- 1Ïù∏Îãπ Î™©Ìëú: ${perPlayerMinGames}Í≤ΩÍ∏∞`);
      
      // Í≤ΩÍ∏∞ Ïàò Î∂ÑÌè¨ Ï∂úÎ†•
      const distribution: Record<number, number> = {};
      Object.values(finalCounts).forEach((count: any) => {
        distribution[count] = (distribution[count] || 0) + 1;
      });
      console.log('- Í≤ΩÍ∏∞ Ïàò Î∂ÑÌè¨:', distribution);
      
      setMatches(generated);
      setSessionMode('Î†àÎ≤®');
      setPlayerGameCounts(finalCounts);
    } catch (e) {
      console.error('Î†àÎ≤®Î≥Ñ Í≤ΩÍ∏∞ ÏÉùÏÑ± Ï§ë Ïò§Î•ò:', e);
      alert('Î†àÎ≤®Î≥Ñ Í≤ΩÍ∏∞ ÏÉùÏÑ± Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
    } finally {
      setLoading(false);
    }
  };

  const handleAssignRandom = async () => {
    if (!todayPlayers) return;
    setLoading(true);
    try {
      const present = todayPlayers.filter(p => p.status === 'present');
      if (present.length < 4) { alert('ÏµúÏÜå 4Î™ÖÏùò Ï∂úÏÑùÏûêÍ∞Ä ÌïÑÏöîÌï©ÎãàÎã§.'); return; }
      // normalize levels for scoring
      const playersForMatch = present.map(p => ({ ...p, skill_level: normalizeLevel(p.skill_level) }));
      const { createRandomBalancedDoublesMatches } = await import('@/utils/match-utils');
      const targetMatches = Math.ceil((playersForMatch.length * perPlayerMinGames) / 4);
      let generated: any[] = [];
      let attempts = 0;
      let maxCourts = Math.max(4, Math.ceil(playersForMatch.length / 4));
      while (attempts < 4) {
        generated = createRandomBalancedDoublesMatches(playersForMatch, maxCourts, perPlayerMinGames).map((m: any, i: number) => ({ ...m, court: i + 1 }));
        const counts = calculatePlayerGameCounts(generated);
        const missing = playersForMatch.filter(p => (counts[p.id] || 0) < perPlayerMinGames);
        if (generated.length >= targetMatches && missing.length === 0) break;
        attempts += 1;
        maxCourts = Math.min(playersForMatch.length, maxCourts + 2);
      }
      const finalCounts = calculatePlayerGameCounts(generated);
      const stillMissing = playersForMatch.filter(p => (finalCounts[p.id] || 0) < perPlayerMinGames);
      if (stillMissing.length > 0) {
        console.warn(`${stillMissing.length}Î™ÖÏùò ÏÑ†ÏàòÍ∞Ä Î™©Ìëú Í≤ΩÍ∏∞ÏàòÏóê ÎèÑÎã¨ÌïòÏßÄ Î™ªÌñàÏäµÎãàÎã§. (ÏÉùÏÑ±Îêú Í≤ΩÍ∏∞ ${generated.length}Í∞ú)`);
      }
      setMatches(generated);
      setSessionMode('ÎûúÎç§');
      setPlayerGameCounts(calculatePlayerGameCounts(generated));
    } catch (e) {
      console.error(e);
      alert('ÎûúÎç§ Í≤ΩÍ∏∞ ÏÉùÏÑ± Ï§ë Ïò§Î•ò');
    } finally { setLoading(false); }
  };

  const handleAssignMixed = async () => {
    if (!todayPlayers) return;
    setLoading(true);
    try {
      const present = todayPlayers.filter(p => p.status === 'present');
      if (present.length < 4) { alert('ÏµúÏÜå 4Î™ÖÏùò Ï∂úÏÑùÏûêÍ∞Ä ÌïÑÏöîÌï©ÎãàÎã§.'); return; }
      const playersForMatch = present.map(p => ({ ...p, skill_level: normalizeLevel(p.skill_level) }));
      const { createMixedAndSameSexDoublesMatches } = await import('@/utils/match-utils');
      // target matches = ceil((players * perPlayerMinGames) / 4)
      const targetMatches = Math.ceil((playersForMatch.length * perPlayerMinGames) / 4);
      // try generation multiple times, expanding per-round courts if needed to improve coverage
      let generated: any[] = [];
      let attempts = 0;
      let maxCourts = Math.max(4, Math.ceil(playersForMatch.length / 4));
      while (attempts < 4) {
        generated = createMixedAndSameSexDoublesMatches(playersForMatch, maxCourts, perPlayerMinGames).map((m: any, i: number) => ({ ...m, court: i + 1 }));
        const counts = calculatePlayerGameCounts(generated);
        const missing = playersForMatch.filter(p => (counts[p.id] || 0) < perPlayerMinGames);
        if (generated.length >= targetMatches && missing.length === 0) break;
        // try again with more courts to create more variety
        attempts += 1;
        maxCourts = Math.min(playersForMatch.length, maxCourts + 2);
      }
      // final check
      const finalCounts = calculatePlayerGameCounts(generated);
      const stillMissing = playersForMatch.filter(p => (finalCounts[p.id] || 0) < perPlayerMinGames);
      if (stillMissing.length > 0) {
        console.warn(`${stillMissing.length}Î™ÖÏùò ÏÑ†ÏàòÍ∞Ä Î™©Ìëú Í≤ΩÍ∏∞ÏàòÏóê ÎèÑÎã¨ÌïòÏßÄ Î™ªÌñàÏäµÎãàÎã§. (ÏÉùÏÑ±Îêú Í≤ΩÍ∏∞ ${generated.length}Í∞ú)`);
      }
      setMatches(generated);
      setSessionMode('ÌòºÎ≥µ');
      setPlayerGameCounts(calculatePlayerGameCounts(generated));
    } catch (e) { console.error(e); alert('ÌòºÎ≥µ Í≤ΩÍ∏∞ ÏÉùÏÑ± Ï§ë Ïò§Î•ò'); }
    finally { setLoading(false); }
  };

  const handleManualAssign = () => {
    if (!todayPlayers) return;
    const present = todayPlayers.filter(p => p.status === 'present');
    if (present.length < 4) { alert('ÏµúÏÜå 4Î™ÖÏùò Ï∂úÏÑùÏûêÍ∞Ä ÌïÑÏöîÌï©ÎãàÎã§.'); return; }

    // target matches Í≥ÑÏÇ∞ Î∞è Îπà Ïä¨Î°Ø ÏÉùÏÑ±
    const targetMatches = Math.ceil((present.length * perPlayerMinGames) / 4);
    const emptyMatches: any[] = Array.from({ length: Math.max(1, targetMatches) }).map((_, i) => ({
      id: `manual-empty-${Date.now()}-${i}`,
      team1: { player1: null, player2: null },
      team2: { player1: null, player2: null },
      court: i + 1
    }));

    setMatches(emptyMatches);
    setSessionMode('ÏàòÎèô');
    setPlayerGameCounts({});
    setIsManualEditing(true);
  };

  const handleManualMatchChange = (nextMatches: any[]) => {
    setMatches(nextMatches);
    // Ïã§ÏãúÍ∞ÑÏúºÎ°ú Í≤ΩÍ∏∞ Ïàò ÏóÖÎç∞Ïù¥Ìä∏
    const counts = calculatePlayerGameCounts(nextMatches.filter(m => 
      m.team1?.player1 && m.team1?.player2 && m.team2?.player1 && m.team2?.player2
    ));
    setPlayerGameCounts(counts);
  };

  const handleTeamBasedGeneration = async () => {
    setLoading(true);
    try {
      let allPlayers: any[] = [];

      if (!selectedTeamRound) {
        // ÌåÄ Íµ¨ÏÑ±ÏùÑ ÏÑ†ÌÉùÌïòÏßÄ ÏïäÏùÄ Í≤ΩÏö∞: Ï∂úÏÑùÌïú ÏÑ†Ïàò Ï†ÑÏ≤¥Î°ú ÏÉùÏÑ±
        if (!todayPlayers) {
          alert('Ï∂úÏÑù Îç∞Ïù¥ÌÑ∞Î•º Î∂àÎü¨Ïò§Îäî Ï§ëÏûÖÎãàÎã§.');
          return;
        }
        
        const present = todayPlayers.filter(p => p.status === 'present');
        if (present.length < 4) {
          alert('ÏµúÏÜå 4Î™ÖÏùò Ï∂úÏÑùÏûêÍ∞Ä ÌïÑÏöîÌï©ÎãàÎã§.');
          return;
        }

        allPlayers = present.map(p => ({ ...p, skill_level: normalizeLevel(p.skill_level) }));
        console.log('üìä ÌåÄ Íµ¨Î∂Ñ ÏóÜÏù¥ Ï∂úÏÑùÏûê Ï†ÑÏ≤¥Î°ú Í≤ΩÍ∏∞ ÏÉùÏÑ±:', allPlayers.length, 'Î™Ö');
      } else {
        // ÌåÄ Íµ¨ÏÑ±ÏùÑ ÏÑ†ÌÉùÌïú Í≤ΩÏö∞: Ìï¥Îãπ ÌåÄÏùò Ï∂úÏÑùÌïú ÏÑ†ÏàòÎì§Î°úÎßå ÏÉùÏÑ±
        const selectedTeam = availableTeams.find(t => t.round === selectedTeamRound);
        if (!selectedTeam) {
          alert('ÏÑ†ÌÉùÌïú ÌåÄ Íµ¨ÏÑ±ÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.');
          return;
        }

        if (!todayPlayers) {
          alert('Ï∂úÏÑù Îç∞Ïù¥ÌÑ∞Î•º Î∂àÎü¨Ïò§Îäî Ï§ëÏûÖÎãàÎã§.');
          return;
        }

        // Ï∂úÏÑùÌïú ÏÑ†Ïàò Î™©Î°ù
        const presentPlayers = todayPlayers.filter(p => p.status === 'present');
        if (presentPlayers.length < 4) {
          alert('ÏµúÏÜå 4Î™ÖÏùò Ï∂úÏÑùÏûêÍ∞Ä ÌïÑÏöîÌï©ÎãàÎã§.');
          return;
        }

        // ÌåÄ Íµ¨ÏÑ±ÏóêÏÑú ÏÑ†Ïàò Ïù¥Î¶ÑÏùÑ ÌååÏã± (Ïù¥Î¶ÑÍ≥º Î†àÎ≤® Î∂ÑÎ¶¨)
        const parsePlayerName = (nameWithLevel: string) => {
          const match = nameWithLevel.match(/^(.+?)\(([A-Z0-9]+)\)$/);
          if (match) {
            return { name: match[1].trim(), level: match[2].toLowerCase() };
          }
          // Î†àÎ≤® Ï†ïÎ≥¥Í∞Ä ÏóÜÎäî Í≤ΩÏö∞
          return { name: nameWithLevel.trim(), level: 'e2' };
        };

        // Ï∂úÏÑùÌïú ÏÑ†ÏàòÎì§Ïùò Ï†ïÎ≥¥Î•º ÎßµÏúºÎ°ú ÏÉùÏÑ± (Ïù¥Î¶Ñ ‚Üí ÏÑ†Ïàò Ï†ïÎ≥¥)
        const presentPlayersMap = new Map<string, any>();
        presentPlayers.forEach(p => {
          const normalizedName = p.name.trim().toLowerCase();
          presentPlayersMap.set(normalizedName, p);
        });

        // Ïù¥ÎØ∏ Î∞∞Ï†ïÎêú ÏÑ†ÏàòÎì§ÏùÑ Ï∂îÏ†Å
        const assignedPlayers = new Set<string>();

        console.log('üìã Ï∂úÏÑùÌïú ÏÑ†Ïàò Î™©Î°ù:', Array.from(presentPlayersMap.keys()));
        console.log('üìã ÎùºÏºìÌåÄ Íµ¨ÏÑ±:', selectedTeam.racket);
        console.log('üìã ÏÖîÌãÄÌåÄ Íµ¨ÏÑ±:', selectedTeam.shuttle);

        // ÎùºÏºìÌåÄÏóêÏÑú Ï∂úÏÑùÌïú ÏÑ†ÏàòÎßå ÌïÑÌÑ∞ÎßÅÌïòÏó¨ ExtendedPlayerÎ°ú Î≥ÄÌôò
        const racketPlayers: any[] = [];
        selectedTeam.racket.forEach((nameWithLevel, idx) => {
          const parsed = parsePlayerName(nameWithLevel);
          const normalizedName = parsed.name.toLowerCase();
          
          // Ï∂úÏÑùÌïú ÏÑ†Ïàò Ï§ëÏóêÏÑú Ïù¥Î¶ÑÏù¥ ÏùºÏπòÌïòÎäî ÏÑ†Ïàò Ï∞æÍ∏∞
          const presentPlayer = presentPlayersMap.get(normalizedName);
          
          if (presentPlayer) {
            // ÏïÑÏßÅ Î∞∞Ï†ïÎêòÏßÄ ÏïäÏùÄ ÏÑ†ÏàòÏù∏ÏßÄ ÌôïÏù∏
            if (!assignedPlayers.has(normalizedName)) {
              racketPlayers.push({
                id: presentPlayer.id || `racket-${idx}-${Date.now()}`,
                name: presentPlayer.name, // Ï∂úÏÑù Îç∞Ïù¥ÌÑ∞Ïùò ÏõêÎûò Ïù¥Î¶Ñ ÏÇ¨Ïö©
                skill_level: normalizeLevel(presentPlayer.skill_level || parsed.level),
                skill_label: presentPlayer.skill_label || `${parsed.level.toUpperCase()} Î†àÎ≤®`,
                gender: presentPlayer.gender || '',
                skill_code: presentPlayer.skill_code || '',
                status: 'present' as const
              });
              assignedPlayers.add(normalizedName); // Î∞∞Ï†ï ÌëúÏãú
              console.log(`‚úÖ ÎùºÏºìÌåÄ Î∞∞Ï†ï: ${nameWithLevel} ‚Üí ${presentPlayer.name}`);
            } else {
              console.log(`‚ö†Ô∏è ÎùºÏºìÌåÄ Ï§ëÎ≥µ: ${nameWithLevel} (Ïù¥ÎØ∏ Î∞∞Ï†ïÎê®)`);
            }
          } else {
            console.log(`‚ùå ÎùºÏºìÌåÄ Î∂àÏ∞∏: ${nameWithLevel}`);
          }
        });

        // ÏÖîÌãÄÌåÄÏóêÏÑú Ï∂úÏÑùÌïú ÏÑ†ÏàòÎßå ÌïÑÌÑ∞ÎßÅÌïòÏó¨ ExtendedPlayerÎ°ú Î≥ÄÌôò
        const shuttlePlayers: any[] = [];
        selectedTeam.shuttle.forEach((nameWithLevel, idx) => {
          const parsed = parsePlayerName(nameWithLevel);
          const normalizedName = parsed.name.toLowerCase();
          
          // Ï∂úÏÑùÌïú ÏÑ†Ïàò Ï§ëÏóêÏÑú Ïù¥Î¶ÑÏù¥ ÏùºÏπòÌïòÎäî ÏÑ†Ïàò Ï∞æÍ∏∞
          const presentPlayer = presentPlayersMap.get(normalizedName);
          
          if (presentPlayer) {
            // ÏïÑÏßÅ Î∞∞Ï†ïÎêòÏßÄ ÏïäÏùÄ ÏÑ†ÏàòÏù∏ÏßÄ ÌôïÏù∏
            if (!assignedPlayers.has(normalizedName)) {
              shuttlePlayers.push({
                id: presentPlayer.id || `shuttle-${idx}-${Date.now()}`,
                name: presentPlayer.name, // Ï∂úÏÑù Îç∞Ïù¥ÌÑ∞Ïùò ÏõêÎûò Ïù¥Î¶Ñ ÏÇ¨Ïö©
                skill_level: normalizeLevel(presentPlayer.skill_level || parsed.level),
                skill_label: presentPlayer.skill_label || `${parsed.level.toUpperCase()} Î†àÎ≤®`,
                gender: presentPlayer.gender || '',
                skill_code: presentPlayer.skill_code || '',
                status: 'present' as const
              });
              assignedPlayers.add(normalizedName); // Î∞∞Ï†ï ÌëúÏãú
              console.log(`‚úÖ ÏÖîÌãÄÌåÄ Î∞∞Ï†ï: ${nameWithLevel} ‚Üí ${presentPlayer.name}`);
            } else {
              console.log(`‚ö†Ô∏è ÏÖîÌãÄÌåÄ Ï§ëÎ≥µ: ${nameWithLevel} (Ïù¥ÎØ∏ ÎùºÏºìÌåÄÏóê Î∞∞Ï†ïÎê®)`);
            }
          } else {
            console.log(`‚ùå ÏÖîÌãÄÌåÄ Î∂àÏ∞∏: ${nameWithLevel}`);
          }
        });

        allPlayers = [...racketPlayers, ...shuttlePlayers];
        
        console.log('üìä ÏÑ†ÌÉùÌïú ÌåÄ Íµ¨ÏÑ±ÏúºÎ°ú Í≤ΩÍ∏∞ ÏÉùÏÑ±:');
        console.log(`  - ÌöåÏ∞®: ${selectedTeam.round}ÌöåÏ∞®`);
        console.log(`  - ÌåÄ Íµ¨ÏÑ± Ï†ÑÏ≤¥: ${selectedTeam.racket.length + selectedTeam.shuttle.length}Î™Ö`);
        console.log(`  - Ï∂úÏÑùÌïú ÏÑ†Ïàò: ${allPlayers.length}Î™Ö`);
        console.log(`  - ÎùºÏºìÌåÄ Ï∂úÏÑù: ${racketPlayers.length}Î™Ö / ${selectedTeam.racket.length}Î™Ö`);
        console.log(`  - ÏÖîÌãÄÌåÄ Ï∂úÏÑù: ${shuttlePlayers.length}Î™Ö / ${selectedTeam.shuttle.length}Î™Ö`);
        console.log(`  - ÏµúÏ¢Ö ÏÑ†Ïàò Î™©Î°ù:`, allPlayers.map(p => `${p.name}(${p.skill_level})`).join(', '));
      }

      if (allPlayers.length < 4) {
        alert('ÏµúÏÜå 4Î™ÖÏùò ÏÑ†ÏàòÍ∞Ä ÌïÑÏöîÌï©ÎãàÎã§.');
        return;
      }

      const { createBalancedDoublesMatches } = await import('@/utils/match-utils');
      const targetMatches = Math.ceil((allPlayers.length * perPlayerMinGames) / 4);
      
      let generated: any[] = [];
      
      // Í∏∞Ï°¥ Î∞©Ïãù: Î™®Îì† ÏÑ†Ïàò ÌòºÌï©
      let attempts = 0;
      let maxCourts = Math.max(4, Math.ceil(allPlayers.length / 4));
      
      while (attempts < 4) {
        generated = createBalancedDoublesMatches(allPlayers, maxCourts, perPlayerMinGames)
          .map((m: any, i: number) => ({ ...m, court: i + 1 }));
        
        const counts = calculatePlayerGameCounts(generated);
        const missing = allPlayers.filter(p => (counts[p.id] || 0) < perPlayerMinGames);
        
        if (generated.length >= targetMatches && missing.length === 0) {
          break;
        }
        
        attempts += 1;
        maxCourts = Math.min(allPlayers.length, maxCourts + 2);
      }
      
      const finalCounts = calculatePlayerGameCounts(generated);
      
      console.log('‚úÖ Í≤ΩÍ∏∞ ÏÉùÏÑ± ÏôÑÎ£å:');
      console.log(`- Ï¥ù ÏÑ†Ïàò: ${allPlayers.length}Î™Ö`);
      console.log(`- ÏÉùÏÑ±Îêú Í≤ΩÍ∏∞: ${generated.length}Í∞ú`);
      console.log(`- Î™©Ìëú Í≤ΩÍ∏∞Ïàò: ${targetMatches}Í∞ú`);
      
      setMatches(generated);
      setSessionMode(selectedTeamRound ? 'ÌåÄÍµ¨ÏÑ±' as any : 'Î†àÎ≤®');
      setPlayerGameCounts(finalCounts);
    } catch (e) {
      console.error('ÌåÄ Í∏∞Î∞ò Í≤ΩÍ∏∞ ÏÉùÏÑ± Ï§ë Ïò§Î•ò:', e);
      alert('ÌåÄ Í∏∞Î∞ò Í≤ΩÍ∏∞ ÏÉùÏÑ± Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
    } finally {
      setLoading(false);
    }
  };

  const handleManualMatchesCreate = (manualMatches: Match[]) => {
    setMatches(manualMatches);
    setSessionMode('ÏàòÎèô');
    setPlayerGameCounts(calculatePlayerGameCounts(manualMatches));
    console.log(`‚úÖ ÏàòÎèô Î∞∞Ï†ï: ${manualMatches.length}Í∞ú Í≤ΩÍ∏∞ ÏÉùÏÑ± ÏôÑÎ£å`);
  };

  const handleDirectAssign = async () => {
    if (matches.length === 0) { alert('Î∞∞Ï†ïÌï† Í≤ΩÍ∏∞Í∞Ä ÏóÜÏäµÎãàÎã§.'); return; }
  const today = getTodayLocal();
  const mode = sessionMode; // use generation mode (Î†àÎ≤®/ÎûúÎç§/ÌòºÎ≥µ)
  const makeSessionName = async () => {
      // count today sessions to generate sequence
      const { data, error } = await supabase
        .from('match_sessions')
        .select('id', { count: 'exact', head: true })
        .eq('session_date', today);
      const seq = (data as any)?.length ? (data as any).length + 1 : 1; // fallback if head returns no length
      // safer: do a separate count query
      const { count } = await supabase
        .from('match_sessions')
        .select('*', { count: 'exact', head: true })
        .eq('session_date', today);
  const n = (count ?? seq) + 1;
  return `${today}_${mode}_${n}Î≤àÏß∏`;
    };
    const sessionName = await makeSessionName();
    setLoading(true);
    try {
      const { data: sessionData, error: sessionError } = await supabase
        .from('match_sessions')
        .insert({ session_name: sessionName, total_matches: matches.length, assigned_matches: matches.length, session_date: today })
        .select()
        .single();
      if (sessionError) throw sessionError;

      const payload = matches.map((match, idx) => ({
        session_id: sessionData.id,
        match_number: idx + 1,
        team1_player1_id: match.team1.player1.id,
        team1_player2_id: match.team1.player2.id,
        team2_player1_id: match.team2.player1.id,
        team2_player2_id: match.team2.player2.id,
        status: 'scheduled',
        created_at: new Date().toISOString()
      }));
      const { error: insErr } = await supabase.from('generated_matches').insert(payload);
      if (insErr) throw insErr;
  alert(`‚úÖ ${matches.length}Í∞ú Í≤ΩÍ∏∞Í∞Ä Ïò§Îäò ÏàúÏÑúÎåÄÎ°ú Î∞∞Ï†ïÎêòÏóàÏäµÎãàÎã§. (ÏÑ∏ÏÖò: ${sessionName})`);
  setMatches([]); setPlayerGameCounts({});
  await fetchMatchSessions();
  await fetchTodaySchedules();
    } catch (e) {
      console.error('Î∞∞Ï†ï Ïò§Î•ò:', e);
      alert('Î∞∞Ï†ï Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.');
    } finally { setLoading(false); }
  };

  return (
    <RequireAdmin>
      <div className="p-6">
        <h1 className="text-xl font-bold mb-4">Ïò§Îäò Í≤ΩÍ∏∞ ÏÉùÏÑ±/Î∞∞Ï†ï</h1>
        {/* Ïò§ÎäòÏùò Îì±Î°ùÎêú Í≤ΩÍ∏∞ - ÏµúÏÉÅÎã®ÏúºÎ°ú Ïù¥Îèô */}
        <div className="mb-6 p-4 border border-purple-300 rounded bg-purple-50">
          <h3 className="text-lg font-semibold mb-3">üóìÔ∏è Ïò§ÎäòÏùò Îì±Î°ùÎêú Í≤ΩÍ∏∞</h3>
          {todaySchedules.length === 0 ? (
            <div className="text-gray-600 text-sm">Ïò§Îäò Îì±Î°ùÎêú Í≤ΩÍ∏∞Í∞Ä ÏóÜÏäµÎãàÎã§.</div>
          ) : (
            <div className="grid grid-cols-1 sm:grid-cols-2 gap-3">
              {todaySchedules.map((s) => (
                <div key={s.id} className="bg-white rounded border p-3 text-sm">
                  <div className="font-medium text-gray-800">{s.start_time} - {s.end_time} ¬∑ {s.location}</div>
                  <div className="text-gray-600 mt-1">
                    Ïù∏Ïõê: {s.current_participants ?? 0} / {s.max_participants ?? 0}Î™Ö
                  </div>
                  <div className="text-xs mt-1">
                    ÏÉÅÌÉú: <span className="font-medium">{s.status}</span>
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>
        <AttendanceStatus todayPlayers={todayPlayers} />
        
        {/* ÏàòÎèô Í∞±Ïã† Î≤ÑÌäº */}
        <div className="mb-6 flex gap-4">
          <button
            onClick={() => refreshAttendanceData().catch(err => console.error('ÏàòÎèô Í∞±Ïã† Ïò§Î•ò:', err))}
            className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:opacity-50"
            disabled={loading}
          >
            üîÑ Îç∞Ïù¥ÌÑ∞ ÏàòÎèô Í∞±Ïã†
          </button>
          <button
            onClick={() => {
              fetchMatchSessions();
              fetchTodaySchedules();
            }}
            className="px-4 py-2 bg-green-500 text-white rounded hover:bg-green-600 disabled:opacity-50"
            disabled={loading}
          >
            üìÖ Í≤ΩÍ∏∞ ÏùºÏ†ï Í∞±Ïã†
          </button>
        </div>
        
        <MatchSessionStatus matchSessions={matchSessions} />
        
        {/* ÌåÄ Íµ¨ÏÑ± Í∏∞Î∞ò Í≤ΩÍ∏∞ ÏÉùÏÑ± */}
        <TeamBasedMatchGeneration
          availableTeams={availableTeams}
          selectedTeamRound={selectedTeamRound}
          onTeamSelect={setSelectedTeamRound}
          onGenerateMatches={handleTeamBasedGeneration}
          perPlayerMinGames={perPlayerMinGames}
        />
        
        <MatchGenerationControls
          todayPlayers={todayPlayers}
          perPlayerMinGames={perPlayerMinGames}
          setPerPlayerMinGames={setPerPlayerMinGames}
          onGenerateByLevel={handleAssignByLevel}
          onGenerateRandom={handleAssignRandom}
          onGenerateMixed={handleAssignMixed}
          onManualAssign={handleManualAssign}
        />
        
        {/* ÏÉùÏÑ±Îêú Í≤ΩÍ∏∞ Î™©Î°ù (ÏàòÎèô Î∞∞Ï†ï Î™®Îìú Ìè¨Ìï®) */}
        <GeneratedMatchesList
          matches={matches}
          playerGameCounts={playerGameCounts}
          assignType={assignType}
          setAssignType={setAssignType}
          loading={loading}
          onClearMatches={() => { 
            setMatches([]); 
            setPlayerGameCounts({}); 
            setIsManualEditing(false); 
          }}
          onAssignMatches={handleDirectAssign}
          isManualMode={isManualEditing}
          presentPlayers={todayPlayers?.filter(p => p.status === 'present') || []}
          onManualMatchChange={handleManualMatchChange}
        />
      </div>
    </RequireAdmin>
  );
}
